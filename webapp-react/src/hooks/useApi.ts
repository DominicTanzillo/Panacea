// Generated by Claude Code -- 2026-02-13
import { useState, useEffect, useCallback } from 'react';
import type {
  ModelComparisonResult,
  StalenessResults,
  ScreeningPair,
} from '../lib/api';
import {
  health as apiHealth,
  getModelComparison,
  getExperimentResults,
  bulkScreen,
} from '../lib/api';
import type { TLERecord } from '../lib/types';

interface UseApiResult {
  healthy: boolean;
  modelComparison: ModelComparisonResult[] | null;
  experimentResults: StalenessResults | null;
  screeningPairs: ScreeningPair[];
  loading: boolean;
  refresh: () => void;
}

export function useApi(tles?: TLERecord[]): UseApiResult {
  const [healthy, setHealthy] = useState(false);
  const [modelComparison, setModelComparison] = useState<ModelComparisonResult[] | null>(null);
  const [experimentResults, setExperimentResults] = useState<StalenessResults | null>(null);
  const [screeningPairs, setScreeningPairs] = useState<ScreeningPair[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchData = useCallback(async () => {
    setLoading(true);

    // Check health first
    const healthResp = await apiHealth();
    const isHealthy = healthResp?.status === 'healthy';
    setHealthy(isHealthy);

    if (!isHealthy) {
      setLoading(false);
      return;
    }

    // Fetch data in parallel
    const [comparison, experiment] = await Promise.all([
      getModelComparison(),
      getExperimentResults(),
    ]);

    if (comparison) setModelComparison(comparison);
    if (experiment && !('error' in experiment)) {
      setExperimentResults(experiment);
    }

    setLoading(false);
  }, []);

  // Initial fetch + poll health every 30s
  useEffect(() => {
    fetchData();
    const timer = setInterval(async () => {
      const resp = await apiHealth();
      setHealthy(resp?.status === 'healthy');
    }, 30000);
    return () => clearInterval(timer);
  }, [fetchData]);

  // Screen TLEs when available and API is healthy
  useEffect(() => {
    if (!healthy || !tles || tles.length < 100) return;

    // Sample up to 2000 TLEs for screening (avoid overloading)
    const sample = tles.length > 2000
      ? tles.filter((_, i) => i % Math.ceil(tles.length / 2000) === 0)
      : tles;

    bulkScreen(sample as unknown as Record<string, unknown>[], 10).then(resp => {
      if (resp?.pairs) setScreeningPairs(resp.pairs);
    });
  }, [healthy, tles]);

  return {
    healthy,
    modelComparison,
    experimentResults,
    screeningPairs,
    loading,
    refresh: fetchData,
  };
}
