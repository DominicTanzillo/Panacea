// Generated by Claude Code -- 2026-02-13
import { useEffect, useRef, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import * as satellite from 'satellite.js';

const GEOJSON_URL = 'https://unpkg.com/world-atlas@2.0.2/countries-110m.json';

// Convert lat/lon (degrees) to 3D position on a unit sphere
function latLonToVec3(lat: number, lon: number, radius: number): THREE.Vector3 {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);
  return new THREE.Vector3(
    -radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.sin(theta)
  );
}

// Parse TopoJSON to line segments
function topoToLineSegments(topo: any): Float32Array {
  const segments: number[] = [];
  const radius = 1.001; // Slightly above Earth surface

  // TopoJSON uses arcs — extract them first
  const arcs: number[][][] = topo.arcs.map((arc: number[][]) => {
    const coords: number[][] = [];
    let x = 0, y = 0;
    for (const [dx, dy] of arc) {
      x += dx;
      y += dy;
      const lon = x * topo.transform.scale[0] + topo.transform.translate[0];
      const lat = y * topo.transform.scale[1] + topo.transform.translate[1];
      coords.push([lon, lat]);
    }
    return coords;
  });

  // Decode geometries → line segments
  const objects = topo.objects;
  for (const key of Object.keys(objects)) {
    const obj = objects[key];
    const geometries = obj.type === 'GeometryCollection' ? obj.geometries : [obj];

    for (const geom of geometries) {
      const arcIndices: number[][] = [];

      if (geom.type === 'Polygon') {
        arcIndices.push(...geom.arcs);
      } else if (geom.type === 'MultiPolygon') {
        for (const polygon of geom.arcs) {
          arcIndices.push(...polygon);
        }
      }

      for (const ring of arcIndices) {
        const coords: number[][] = [];
        for (const idx of ring) {
          const arc = idx >= 0 ? arcs[idx] : [...arcs[~idx]].reverse();
          coords.push(...arc);
        }

        // Convert coordinate pairs to line segments
        for (let i = 0; i < coords.length - 1; i++) {
          const [lon1, lat1] = coords[i];
          const [lon2, lat2] = coords[i + 1];

          // Skip segments that wrap around the antimeridian
          if (Math.abs(lon2 - lon1) > 90) continue;

          const v1 = latLonToVec3(lat1, lon1, radius);
          const v2 = latLonToVec3(lat2, lon2, radius);

          segments.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);
        }
      }
    }
  }

  return new Float32Array(segments);
}

interface CountryBordersProps {
  visible: boolean;
}

export function CountryBorders({ visible }: CountryBordersProps) {
  const groupRef = useRef<THREE.Group>(null);
  const [geometry, setGeometry] = useState<THREE.BufferGeometry | null>(null);

  // Load and parse GeoJSON on mount
  useEffect(() => {
    if (!visible) return;

    let cancelled = false;

    fetch(GEOJSON_URL)
      .then(res => res.json())
      .then(topo => {
        if (cancelled) return;
        const positions = topoToLineSegments(topo);
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        setGeometry(geo);
      })
      .catch(err => console.error('Failed to load country borders:', err));

    return () => { cancelled = true; };
  }, [visible]);

  // Rotate borders with Earth (match GMST rotation)
  useFrame(() => {
    if (groupRef.current) {
      const gmst = satellite.gstime(new Date());
      groupRef.current.rotation.y = gmst;
    }
  });

  if (!visible || !geometry) return null;

  return (
    <group ref={groupRef}>
      <lineSegments geometry={geometry} frustumCulled={false}>
        <lineBasicMaterial
          color="#ffffff"
          transparent
          opacity={0.15}
          depthWrite={false}
        />
      </lineSegments>
    </group>
  );
}
