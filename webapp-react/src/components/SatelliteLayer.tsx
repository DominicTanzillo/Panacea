// Generated by Claude Code -- 2026-02-13
import { useRef, useMemo, useCallback } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import type { SatellitePosition } from '../lib/types';
import { TYPE_COLORS, EARTH_RADIUS_KM } from '../lib/types';

interface SatelliteLayerProps {
  satellites: SatellitePosition[];
  onSelect: (sat: SatellitePosition | null) => void;
  selected: SatellitePosition | null;
}

// Pre-parse color map once at module level
const PARSED_COLORS: Record<string, [number, number, number]> = {};
for (const [key, hex] of Object.entries(TYPE_COLORS)) {
  const c = new THREE.Color(hex);
  PARSED_COLORS[key] = [c.r, c.g, c.b];
}
const WHITE_RGB: [number, number, number] = [1, 1, 1];

const SCALE = 1 / EARTH_RADIUS_KM;

// Trail: 60 seconds behind (no forward prediction)
const TRAIL_SECONDS = 60;

export function SatelliteLayer({ satellites, onSelect, selected }: SatelliteLayerProps) {
  const pointsRef = useRef<THREE.Points>(null);
  const trailRef = useRef<THREE.LineSegments>(null);
  const { raycaster, pointer, camera } = useThree();

  // Store base position + velocity data for interpolation
  const satDataRef = useRef<{
    positions: Float32Array;
    velocities: Float32Array;
    colors: Float32Array;
    propagatedAt: Float64Array;
    count: number;
  }>({ positions: new Float32Array(0), velocities: new Float32Array(0), colors: new Float32Array(0), propagatedAt: new Float64Array(0), count: 0 });

  // Update base data when satellites change (from propagation)
  useMemo(() => {
    const n = satellites.length;
    const positions = new Float32Array(n * 3);
    const velocities = new Float32Array(n * 3);
    const colors = new Float32Array(n * 3);
    const propagatedAt = new Float64Array(n);

    for (let i = 0; i < n; i++) {
      const sat = satellites[i];
      const i3 = i * 3;

      // ECI km to scene units, Y-up coordinate swap
      positions[i3] = sat.x * SCALE;
      positions[i3 + 1] = sat.z * SCALE;
      positions[i3 + 2] = -sat.y * SCALE;

      // Velocity: km/s to scene units/s, same coord swap
      velocities[i3] = sat.vx * SCALE;
      velocities[i3 + 1] = sat.vz * SCALE;
      velocities[i3 + 2] = -sat.vy * SCALE;

      propagatedAt[i] = sat.propagatedAt;

      const rgb = PARSED_COLORS[sat.type] || WHITE_RGB;
      colors[i3] = rgb[0];
      colors[i3 + 1] = rgb[1];
      colors[i3 + 2] = rgb[2];
    }

    satDataRef.current = { positions, velocities, colors, propagatedAt, count: n };
  }, [satellites]);

  // Animated position buffer (updated every frame)
  const animatedGeo = useMemo(() => {
    const geo = new THREE.BufferGeometry();
    const n = satellites.length;
    geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(n * 3), 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(n * 3), 3));
    return geo;
  }, [satellites.length]);

  // Trail line geometry: one segment per satellite (trail behind → current position)
  const trailGeo = useMemo(() => {
    const geo = new THREE.BufferGeometry();
    const n = satellites.length;
    // 1 line segment = 2 vertices per satellite
    geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(n * 2 * 3), 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(n * 2 * 3), 3));
    return geo;
  }, [satellites.length]);

  // Per-frame animation: interpolate positions using velocity vectors
  useFrame(() => {
    const data = satDataRef.current;
    if (data.count === 0) return;

    const now = Date.now();
    const n = data.count;

    // Update satellite point positions
    const posAttr = animatedGeo.getAttribute('position') as THREE.BufferAttribute;
    const colAttr = animatedGeo.getAttribute('color') as THREE.BufferAttribute;
    const posArr = posAttr.array as Float32Array;
    const colArr = colAttr.array as Float32Array;

    // Update trail line positions
    const tPosAttr = trailGeo.getAttribute('position') as THREE.BufferAttribute;
    const tColAttr = trailGeo.getAttribute('color') as THREE.BufferAttribute;
    const tPosArr = tPosAttr.array as Float32Array;
    const tColArr = tColAttr.array as Float32Array;

    if (posArr.length !== n * 3) return;

    for (let i = 0; i < n; i++) {
      const i3 = i * 3;
      const dt = (now - data.propagatedAt[i]) / 1000; // seconds since propagation

      // Interpolated current position = base + velocity * dt
      const cx = data.positions[i3] + data.velocities[i3] * dt;
      const cy = data.positions[i3 + 1] + data.velocities[i3 + 1] * dt;
      const cz = data.positions[i3 + 2] + data.velocities[i3 + 2] * dt;

      posArr[i3] = cx;
      posArr[i3 + 1] = cy;
      posArr[i3 + 2] = cz;

      colArr[i3] = data.colors[i3];
      colArr[i3 + 1] = data.colors[i3 + 1];
      colArr[i3 + 2] = data.colors[i3 + 2];

      // Trail line: 2 vertices per satellite (trail start → current position)
      const ti = i * 6; // 2 vertices * 3 components

      // Trail start: where the satellite was TRAIL_SECONDS ago
      tPosArr[ti] = cx + data.velocities[i3] * (-TRAIL_SECONDS);
      tPosArr[ti + 1] = cy + data.velocities[i3 + 1] * (-TRAIL_SECONDS);
      tPosArr[ti + 2] = cz + data.velocities[i3 + 2] * (-TRAIL_SECONDS);

      // Trail end: current position
      tPosArr[ti + 3] = cx;
      tPosArr[ti + 4] = cy;
      tPosArr[ti + 5] = cz;

      // Trail color: faded at tail, brighter near satellite
      const r = data.colors[i3];
      const g = data.colors[i3 + 1];
      const b = data.colors[i3 + 2];

      // Trail start (faded)
      tColArr[ti] = r * 0.1;
      tColArr[ti + 1] = g * 0.1;
      tColArr[ti + 2] = b * 0.1;
      // Trail end at current pos (brighter)
      tColArr[ti + 3] = r * 0.7;
      tColArr[ti + 4] = g * 0.7;
      tColArr[ti + 5] = b * 0.7;
    }

    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    tPosAttr.needsUpdate = true;
    tColAttr.needsUpdate = true;
  });

  // Click handler — find nearest point
  const handleClick = useCallback(() => {
    if (!pointsRef.current) return;

    raycaster.setFromCamera(pointer, camera);
    raycaster.params.Points = { threshold: 0.02 };
    const intersects = raycaster.intersectObject(pointsRef.current);

    if (intersects.length > 0 && intersects[0].index !== undefined) {
      const idx = intersects[0].index;
      if (idx < satellites.length) {
        onSelect(satellites[idx]);
        return;
      }
    }
    onSelect(null);
  }, [satellites, onSelect, raycaster, pointer, camera]);

  return (
    <group>
      {/* Trailing trajectory lines (behind each satellite) */}
      <lineSegments ref={trailRef} geometry={trailGeo} frustumCulled={false}>
        <lineBasicMaterial
          vertexColors
          transparent
          opacity={0.4}
          depthWrite={false}
          toneMapped={false}
          linewidth={1}
        />
      </lineSegments>

      {/* Current satellite positions (smoothly animated) */}
      <points
        ref={pointsRef}
        geometry={animatedGeo}
        onClick={handleClick}
        frustumCulled={false}
      >
        <pointsMaterial
          size={2.5}
          vertexColors
          sizeAttenuation={false}
          transparent
          opacity={0.9}
          depthWrite={false}
          toneMapped={false}
        />
      </points>

      {/* Selection ring for selected satellite */}
      {selected && <SelectionRing satellite={selected} />}
    </group>
  );
}

// Ring around selected satellite — always faces the camera (billboard)
export function SelectionRing({ satellite }: { satellite: SatellitePosition }) {
  const groupRef = useRef<THREE.Group>(null);
  const innerRef = useRef<THREE.Mesh>(null);
  const { camera } = useThree();

  useFrame(() => {
    if (groupRef.current) {
      const dt = (Date.now() - satellite.propagatedAt) / 1000;
      groupRef.current.position.set(
        (satellite.x + satellite.vx * dt) * SCALE,
        (satellite.z + satellite.vz * dt) * SCALE,
        -(satellite.y + satellite.vy * dt) * SCALE,
      );
      // Billboard: make the ring always face the camera
      groupRef.current.quaternion.copy(camera.quaternion);
    }
    if (innerRef.current) {
      innerRef.current.rotation.z += 0.03;
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={innerRef}>
        <ringGeometry args={[0.02, 0.025, 32]} />
        <meshBasicMaterial color="#4f8aff" side={THREE.DoubleSide} transparent opacity={0.8} />
      </mesh>
    </group>
  );
}
