// Generated by Claude Code -- 2026-02-13
import { useRef, useMemo, useCallback, useEffect } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import type { SatellitePosition } from '../lib/types';
import { TYPE_COLORS, EARTH_RADIUS_KM } from '../lib/types';

interface SatelliteLayerProps {
  satellites: SatellitePosition[];
  onSelect: (sat: SatellitePosition | null) => void;
  selected: SatellitePosition | null;
}

// Pre-parse color map once at module level
const PARSED_COLORS: Record<string, [number, number, number]> = {};
for (const [key, hex] of Object.entries(TYPE_COLORS)) {
  const c = new THREE.Color(hex);
  PARSED_COLORS[key] = [c.r, c.g, c.b];
}
const WHITE_RGB: [number, number, number] = [1, 1, 1];

const TRAIL_LENGTH = 4; // Number of previous position snapshots to keep
const TRAIL_OPACITIES = [0.45, 0.30, 0.18, 0.08]; // Fading opacity per trail layer
const TRAIL_SIZES = [2.0, 1.6, 1.2, 0.9]; // Shrinking point sizes

export function SatelliteLayer({ satellites, onSelect }: SatelliteLayerProps) {
  const pointsRef = useRef<THREE.Points>(null);
  const { raycaster, pointer, camera } = useThree();

  // Trail: circular buffer of previous position arrays
  const trailRef = useRef<Float32Array[]>([]);
  const prevCountRef = useRef(0);

  // Build typed arrays for positions and colors from satellite data
  const { positionArray, colorArray } = useMemo(() => {
    const n = satellites.length;
    const positions = new Float32Array(n * 3);
    const colors = new Float32Array(n * 3);
    const scale = 1 / EARTH_RADIUS_KM;

    for (let i = 0; i < n; i++) {
      const sat = satellites[i];
      const i3 = i * 3;

      // ECI km to scene units (Earth radii), Y-up coordinate swap
      positions[i3] = sat.x * scale;
      positions[i3 + 1] = sat.z * scale;   // ECI Z -> scene Y
      positions[i3 + 2] = -sat.y * scale;  // ECI Y -> scene -Z

      const rgb = PARSED_COLORS[sat.type] || WHITE_RGB;
      colors[i3] = rgb[0];
      colors[i3 + 1] = rgb[1];
      colors[i3 + 2] = rgb[2];
    }

    return { positionArray: positions, colorArray: colors, count: n };
  }, [satellites]);

  // Update trail buffer when positions change
  useEffect(() => {
    const n = satellites.length;
    // Only push to trail if satellite count is consistent (no add/remove flicker)
    if (n === prevCountRef.current && n > 0) {
      const trail = trailRef.current;
      // Push current position snapshot as newest trail entry
      trail.unshift(new Float32Array(positionArray));
      // Keep only TRAIL_LENGTH entries
      if (trail.length > TRAIL_LENGTH) {
        trail.length = TRAIL_LENGTH;
      }
    } else {
      // Count changed — reset trails to avoid mismatched indices
      trailRef.current = [];
    }
    prevCountRef.current = n;
  }, [positionArray, satellites.length]);

  // Build geometry from typed arrays
  const geometry = useMemo(() => {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positionArray, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
    return geo;
  }, [positionArray, colorArray]);

  // Build trail geometries
  const trailGeometries = useMemo(() => {
    return trailRef.current.map((trailPositions) => {
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
      return geo;
    });
    // Re-derive when main positions update (trail buffer updates in the effect above)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [positionArray, colorArray]);

  // Click handler — find nearest point to click
  const handleClick = useCallback(() => {
    if (!pointsRef.current) return;

    raycaster.setFromCamera(pointer, camera);
    raycaster.params.Points = { threshold: 0.02 };
    const intersects = raycaster.intersectObject(pointsRef.current);

    if (intersects.length > 0 && intersects[0].index !== undefined) {
      const idx = intersects[0].index;
      if (idx < satellites.length) {
        onSelect(satellites[idx]);
        return;
      }
    }
    onSelect(null);
  }, [satellites, onSelect, raycaster, pointer, camera]);

  return (
    <group>
      {/* Trail layers — rendered behind current positions */}
      {trailGeometries.map((geo, i) => (
        <points key={`trail-${i}`} geometry={geo} frustumCulled={false}>
          <pointsMaterial
            size={TRAIL_SIZES[i] ?? 0.8}
            vertexColors
            sizeAttenuation={false}
            transparent
            opacity={TRAIL_OPACITIES[i] ?? 0.05}
            depthWrite={false}
            toneMapped={false}
          />
        </points>
      ))}

      {/* Current satellite positions */}
      <points
        ref={pointsRef}
        geometry={geometry}
        onClick={handleClick}
        frustumCulled={false}
      >
        <pointsMaterial
          size={2.5}
          vertexColors
          sizeAttenuation={false}
          transparent
          opacity={0.9}
          depthWrite={false}
          toneMapped={false}
        />
      </points>
    </group>
  );
}

// Ring around selected satellite
export function SelectionRing({ satellite }: { satellite: SatellitePosition }) {
  const meshRef = useRef<THREE.Mesh>(null);

  const position = useMemo((): [number, number, number] => {
    const scale = 1 / EARTH_RADIUS_KM;
    return [
      satellite.x * scale,
      satellite.z * scale,
      -satellite.y * scale,
    ];
  }, [satellite]);

  useFrame((_, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.z += delta * 2;
    }
  });

  return (
    <mesh ref={meshRef} position={position}>
      <ringGeometry args={[0.02, 0.025, 32]} />
      <meshBasicMaterial color="#4f8aff" side={THREE.DoubleSide} transparent opacity={0.8} />
    </mesh>
  );
}
